import { IDsArray } from './index';

function sqDist(ax: number, ay: number, bx: number, by: number): number {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}

export default function within(
  ids: IDsArray,
  coords: Float64Array,
  qx: number,
  qy: number,
  r: number,
  nodeSize: number,
): number[] {
  const stack = [0, ids.length - 1, 0];
  const result = [];
  const r2 = r * r;

  // recursively search for items within radius in the kd-sorted arrays
  while (stack.length) {
    const axis = stack.pop()!;
    const right = stack.pop()!;
    const left = stack.pop()!;

    // if we reached "tree node", search linearly
    if (right - left <= nodeSize) {
      for (let i = left; i <= right; i++) {
        if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);
      }
      continue;
    }

    // otherwise find the middle index
    const m = (left + right) >> 1;

    // include the middle item if it's in range
    const x = coords[2 * m];
    const y = coords[2 * m + 1];
    if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);

    // queue search in halves that intersect the query
    if (axis === 0 ? qx - r <= x : qy - r <= y) {
      stack.push(left);
      stack.push(m - 1);
      stack.push(1 - axis);
    }
    if (axis === 0 ? qx + r >= x : qy + r >= y) {
      stack.push(m + 1);
      stack.push(right);
      stack.push(1 - axis);
    }
  }

  return result;
}
